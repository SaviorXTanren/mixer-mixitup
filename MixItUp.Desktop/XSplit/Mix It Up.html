<html>
<head>
  <meta charset="utf-8">
  <style>
    body {
      color: white;
    }
  </style>
</head>
<body>
  <div id='eventsDiv'>
    Mix It Up Events:<BR><BR>
  </div>

  <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
  <script src="https://cdn2.xsplit.com/xjs/download/xjs-es2015.min.js"></script>
  <script src="../Overlay/webSocketWrapper.js"></script>

  <script>
    var xjs = _require('xjs');
    var eventsDiv = document.getElementById('eventsDiv');
    var disconnected = true;

    function connectionOpened() {
      eventsDiv.innerHTML += 'Connected to Mix It Up!<BR>';
      disconnected = false;
    }

    function connectionClosed() {
      if (!disconnected) {
        eventsDiv.innerHTML += 'Disconnected from Mix It Up!<BR>';
        disconnected = true;
      }
    }

    function packetReceived(packet) {
      try {
        if (packet !== null && typeof packet.type !== 'undefined') {
          if (packet.type === 'test') {
            eventsDiv.innerHTML += 'Connection Test Successful!<BR>';
          }
          else if (packet.type === 'sceneTransition') {
            sceneTransition(packet.data);
          }
          else if (packet.type === 'sourceUpdate') {
            sourceUpdate(packet.data);
          }
          else if (packet.type === 'startStopStream') {
            startStopStream(packet.data);
          }
        }
      }
      catch (err) { logException(err); }
    }

    async function sceneTransition(data) {
      try {
        eventsDiv.innerHTML += 'Scene Transition: ' + data.sceneName + '<BR>';

        await xjs.ready();
        let scenes = await xjs.Scene.getByName(data.sceneName);
        if (scenes !== null && scenes.length > 0) {
            await xjs.Scene.setActiveScene(scenes[0]);
        }
      }
      catch (err) { logException(err); }
    }

    async function sourceUpdate(data) {
      try {
        eventsDiv.innerHTML += 'Source Update: ' + data.sceneName + ' - ' + data.sourceName + ' - ' + data.sourceVisible + '<BR>';

        await xjs.ready();

        let scene = null;
        if (!isStringEmpty(data.sceneName)) {
          scene = await xjs.Scene.getByName(data.sceneName);
        }
        else {
          scene = await xjs.Scene.getActiveScene();
        }

        if (Array.isArray(scene)) {
          scene = scene[0];
        }

        let sources = await scene.getSources();
        if (sources !== null && sources.length > 0) {
          for (let i = 0; i < sources.length; i++) {
            let sourceName = await sources[i].getCustomName();
            if (sourceName.length === 0) {
              sourceName = await sources[i].getName();
            }
            if (sourceName === data.sourceName) {
              if (data.webBrowserUrl) {
                eventsDiv.innerHTML += 'Source Web Browser Update: ' + data.webBrowserUrl + '<BR>';
                try {
                  sources[i].setURL(data.webBrowserUrl);
                }
                catch (err) { logException(err); }
              }

              let items = await sources[i].getItemList();
              if (items !== null && items.length > 0) {
                for (let j = 0; j < items.length; j++) {
                  try {
                    await items[j].setVisible(data.sourceVisible);
                  }
                  catch (err) { logException(err); }
                }
              }
            }
          }
        }
      }
      catch (err) { logException(err); }
    }

    async function startStopStream(data) {
      try {
        await xjs.ready();
        let channels = await xjs.StreamInfo.getActiveStreamChannels();
        var isOnline = false;
        for (let i = 0; i < channels.length; i++) {
          let channelName = await channels[i].getName();
          if (channelName.includes(data.outputName)) {
            isOnline = true;
            break;
          }
        }

        let outputs = await xjs.Output.getOutputList();
        for (let i = 0; i < outputs.length; i++) {
          let outputName = await outputs[i].getName();
          if (outputName.includes(data.outputName)) {
            if (isOnline) {
              eventsDiv.innerHTML += 'Stopping broadcast<BR>';
              await outputs[i].stopBroadcast();
            } else {
              eventsDiv.innerHTML += 'Starting broadcast<BR>';
              await outputs[i].startBroadcast({
                suppressPrestreamDialog: true
              });
            }
          }
        }
      }
      catch (err) { logException(err); }
    }

    function logException(err) {
      eventsDiv.innerHTML += 'Error Occurred: ' + err.toString() + '<BR>';
      logToSessionStorage(err);
    }

    openWebsocketConnectionWithAddress('localhost', '8211');
  </script>
</body>

</html>